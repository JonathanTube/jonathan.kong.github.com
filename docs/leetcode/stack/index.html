<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-leetcode/stack" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.3">
<title data-rh="true">Stack | Jonathan&#x27;s Blog</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://jonathantube.github.io/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://jonathantube.github.io/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://jonathantube.github.io/docs/leetcode/stack"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Stack | Jonathan&#x27;s Blog"><meta data-rh="true" name="description" content="232. Implement Queue using Stacks"><meta data-rh="true" property="og:description" content="232. Implement Queue using Stacks"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://jonathantube.github.io/docs/leetcode/stack"><link data-rh="true" rel="alternate" href="https://jonathantube.github.io/docs/leetcode/stack" hreflang="en"><link data-rh="true" rel="alternate" href="https://jonathantube.github.io/docs/leetcode/stack" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Jonathan&#39;s Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Jonathan&#39;s Blog Atom Feed"><link rel="stylesheet" href="/assets/css/styles.d0bc7f13.css">
<link rel="preload" href="/assets/js/runtime~main.111a47fd.js" as="script">
<link rel="preload" href="/assets/js/main.a6abb70e.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}return t}()||function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.jpeg" alt="Programming Monkey" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/logo.jpeg" alt="Programming Monkey" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">Jonathan&#x27;s blog</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/category/javascript-es6">Tutorial</a><a class="navbar__item navbar__link" href="/blog">Blog</a><a class="navbar__item navbar__link" href="/projects">Projects</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/JonathanTube" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><a href="https://gitee.com/kongxm/projects" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Gitee<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebarViewport_Xe31"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/javascript-es6">Javascript ES6</a><button aria-label="Toggle the collapsible sidebar category &#x27;Javascript ES6&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" href="/docs/category/algorithm-learning">Algorithm Learning</a><button aria-label="Toggle the collapsible sidebar category &#x27;Algorithm Learning&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/leetcode/string">String</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/leetcode/linkedList">linkedList</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/leetcode/queue">Queue</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/leetcode/stack">Stack</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/leetcode/divide and conquer">Divide and Conquer &amp; Recursion</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/leetcode/dfs&amp;bsf">DFS&amp;BSF</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/leetcode/matrix">matrix</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/leetcode/graph">Graph DFS&amp;BFS</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/leetcode/binary tree">binary tree</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/leetcode/greedy">greedy</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/leetcode/two pointers">two pointers</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/react-learning">React Learning</a><button aria-label="Toggle the collapsible sidebar category &#x27;React Learning&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/react-router">React Router</a><button aria-label="Toggle the collapsible sidebar category &#x27;React Router&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/redux-learning">Redux Learning</a><button aria-label="Toggle the collapsible sidebar category &#x27;Redux Learning&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/tailwindcss">Tailwindcss</a><button aria-label="Toggle the collapsible sidebar category &#x27;Tailwindcss&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/vue3">Vue3</a><button aria-label="Toggle the collapsible sidebar category &#x27;Vue3&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/project-list">Project List</a><button aria-label="Toggle the collapsible sidebar category &#x27;Project List&#x27;" type="button" class="clean-btn menu__caret"></button></div></li></ul></nav></div></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/docs/category/algorithm-learning"><span itemprop="name">Algorithm Learning</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Stack</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><h1>Stack</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="232-implement-queue-using-stacks">232. Implement Queue using Stacks<a href="#232-implement-queue-using-stacks" class="hash-link" aria-label="Direct link to 232. Implement Queue using Stacks" title="Direct link to 232. Implement Queue using Stacks">​</a></h2><p>Implement a first in first out (FIFO) queue using only two stacks.</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class MyQueue {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 初始化入口</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Stack&lt;Integer&gt; inStack = new Stack&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 初始化出口</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Stack&lt;Integer&gt; outStack = new Stack&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public MyQueue() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void push(int x) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        inStack.push(x);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int pop() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(empty()) return -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(outStack.isEmpty()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 如果出口没有数据，但是入口有数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 需要入口的数据反转到出口，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 那出口的第一个元素就是相对最先加入的元素，也就是队头</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            while(!inStack.isEmpty()) outStack.push(inStack.pop());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return outStack.pop();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int peek() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(empty()) return - 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(outStack.isEmpty()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            while(!inStack.isEmpty()) outStack.push(inStack.pop());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return outStack.peek();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public boolean empty() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 如果入口和出口都没有元素，那就空了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return inStack.isEmpty() &amp;&amp; outStack.isEmpty();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="225-implement-stack-using-queues">225. Implement Stack using Queues<a href="#225-implement-stack-using-queues" class="hash-link" aria-label="Direct link to 225. Implement Stack using Queues" title="Direct link to 225. Implement Stack using Queues">​</a></h2><p>Implement a last-in-first-out (LIFO) stack using only two queues</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class MyStack {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Queue&lt;Integer&gt; inQueue = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int size; // **这里是关键，要记录大小，不然没有size - 1可用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public MyStack() {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void push(int x) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        inQueue.offer(x);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        size ++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 如何拿到队列的最后一个元素？</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int pop() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(empty()) return -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 新建一个临时队列，保存数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Queue&lt;Integer&gt; tempQueue = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int i = 0; i &lt; size - 1; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 将队列弹出size - 1个元素，依次加入临时队列</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 剩下的一个就是最后一个元素，对应栈顶</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            tempQueue.offer(inQueue.poll());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int result = inQueue.poll();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 这里需要再次将出队的数值从tempQueue中再加回去</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        inQueue = tempQueue; // 将临时队列重新指向给inQueue</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        size --; // 记得减少数量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return result;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int top() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(empty()) return -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int result = pop();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        push(result); // 用完记得要加回去</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return result;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public boolean empty() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return size == 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="20-valid-parentheses">20. Valid Parentheses<a href="#20-valid-parentheses" class="hash-link" aria-label="Direct link to 20. Valid Parentheses" title="Direct link to 20. Valid Parentheses">​</a></h2><p>Given a string s containing just the characters &#x27;(&#x27;, &#x27;)&#x27;, &#x27;{&#x27;, &#x27;}&#x27;, &#x27;<!-- -->[&#x27; and &#x27;]<!-- -->&#x27;, determine if the input string is valid.
An input string is valid if:</p><ol><li>Open brackets must be closed by the same type of brackets.</li><li>Open brackets must be closed in the correct order.</li><li>Every close bracket has a corresponding open bracket of the same type.</li></ol><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public boolean isValid(String s) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 如果长度是奇数，直接不满住</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(s.length() % 2 == 1) return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 新建stack; character而不是charactor!!!</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 转换为字符数组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        char[] chars = s.toCharArray();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(char c : chars) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 如果放入的是正括号，直接放入其反括号，便于后续比较</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(c == &#x27;(&#x27;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                stack.push(&#x27;)&#x27;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                continue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(c == &#x27;{&#x27;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                stack.push(&#x27;}&#x27;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                continue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(c == &#x27;[&#x27;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                stack.push(&#x27;]&#x27;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                continue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 如果还有字符，又是反括号，但是栈中已经空了，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 没有正括号了，说明肯定不合法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(stack.isEmpty()) return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 弹出栈顶符号如果不匹配，直接返回false</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(stack.pop() != c) return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 最终括号肯定都是要匹配消除的，如果栈不为空，说明未完全匹配</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return stack.isEmpty();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>921. Minimum Add to Make Parentheses Valid</h1><p>A parentheses string is valid if and only if:</p><ul><li>It is the empty string,</li><li>It can be written as AB (A concatenated with B), where A and B are valid strings, or</li><li>It can be written as (A), where A is a valid string.
You are given a parentheses string s. In one move, you can insert a parenthesis at any position of the string.</li><li>For example, if s = &quot;()))&quot;, you can insert an opening parenthesis to be &quot;(()))&quot; or a closing parenthesis to be &quot;())))&quot;.
Return the minimum number of moves required to make s valid.
Example 1: Input: s = &quot;())&quot;  Output: 1
Example 2:  Input: s = &quot;(((&quot; Output: 3</li></ul><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    * 使用栈的解法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int minAddToMakeValid(String s) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int len = s.length();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(len == 0) return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Stack&lt;Character&gt; myStack = new Stack&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 举例：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // ()); 1-&gt; [&#x27;(&#x27;]; 2-&gt; [&#x27;(&#x27;, &#x27;)&#x27;] =&gt; []; 3-&gt; [&#x27;)&#x27;]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // &quot;(((&quot; 1-&gt; [&#x27;(&#x27;]; 2-&gt; [&#x27;((&#x27;]; 3-&gt; [&#x27;(((&#x27;]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 总结：不停往栈中丢，如果左括号和有括号匹配，出栈；否则入栈</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; len; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Character c = s.charAt(i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(myStack.isEmpty()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                myStack.push(c);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                continue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(myStack.peek() == &#x27;(&#x27; &amp;&amp; c == &#x27;)&#x27;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                myStack.pop();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                continue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            myStack.push(c);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return myStack.size();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>更详细的解释：<a href="https://leetcode.cn/problems/minimum-add-to-make-parentheses-valid/solutions/1622340/by-cheungq-6-5zkx/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/minimum-add-to-make-parentheses-valid/solutions/1622340/by-cheungq-6-5zkx/</a></p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 这里不需要用到栈，所以更快</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int minAddToMakeValid(String s) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int leftSize = 0; // 左括号不匹配数量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int rightSize = 0; // 右括号不匹配数量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int i = 0; i &lt; s.length(); i ++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            char c = s.charAt(i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 遇到左括号：leftSize + 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(c == &#x27;(&#x27;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                leftSize ++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                continue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 遇到右括号，右括号去消除左括号的数量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 这里有个思考的地方，为什么左括号数量大于0，就可以减去左括号的数量，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 如果上一个字符也是右括号呢？不就不能减了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 问题是上一个如果是右括号，那上一个括号应该也判断了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 也就是有没有左括号大于0，但是上一个括号是右括号的情况</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // =&gt; ((() &lt;= &#x27;)&#x27;? 不可能，上一个括号会消掉左括号</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(c == &#x27;)&#x27;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if(leftSize &gt; 0) leftSize --; // 如果未匹配左括号大于0；消掉</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                else rightSize ++; // 否则右括号不匹配数量+1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return leftSize + rightSize; // 左右括号不匹配的数量和</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="856-score-of-parentheses">856. Score of Parentheses<a href="#856-score-of-parentheses" class="hash-link" aria-label="Direct link to 856. Score of Parentheses" title="Direct link to 856. Score of Parentheses">​</a></h2><p>Given a balanced parentheses string s, return the score of the string.
The score of a balanced parentheses string is based on the following rule:</p><ul><li>&quot;()&quot; has score 1.</li><li>AB has score A + B, where A and B are balanced parentheses strings.</li><li>(A) has score 2 * A, where A is a balanced parentheses string.
Example 1: Input: s = &quot;()&quot; Output: 1
Example 2: Input: s = &quot;(())&quot; Output: 2
Example 3: Input: s = &quot;()()&quot; Output: 2</li></ul><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int scoreOfParentheses(String s) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 核心是计算完后，再把结果丢到栈里</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 共有，3种情况</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // () = 1  直接匹配</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // (()) = (1) = 2 * 1  嵌套匹配</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // ()() = 1 + 1 = 2    非嵌套匹配</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(s.length() == 0) return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int i = 0; i &lt; s.length(); i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            char c = s.charAt(i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(stack.isEmpty()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 这里用-1代表左括号</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 因为是匹配的括号，所以第一个肯定是(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                stack.push(-1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                continue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 如果还是左括号</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(c == &#x27;(&#x27;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                stack.push(-1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                continue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 匹配上：栈顶元素为-1，说明是左括号，和当前右括号匹配</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(stack.peek() == -1 &amp;&amp; c == &#x27;)&#x27;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                stack.pop(); // 将左括号弹出</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                stack.push(1); // 入栈匹配括号数量：1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                continue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 如果栈顶元素不是-1，说明是上一次的计算结果</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(stack.peek() != -1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                int num = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 将计算的数字全部弹出并且相加</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                while(stack.peek() != -1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    num += stack.pop();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                num = num * 2; // 说明是(A+B+..)这种情况</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                stack.pop(); // 弹出左括号</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                stack.push(num); // 加入计算好的值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 最后弹出所有累加的数字</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int result = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while(!stack.isEmpty()) result += stack.pop();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return result;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="227-basic-calculator-ii">227. Basic Calculator II<a href="#227-basic-calculator-ii" class="hash-link" aria-label="Direct link to 227. Basic Calculator II" title="Direct link to 227. Basic Calculator II">​</a></h2><p>Given a string s which represents an expression, evaluate this expression and return its value.
The integer division should truncate toward zero.
You may assume that the given expression is always valid. All intermediate results will be in the range of <!-- -->[-2(31), 2(31) - 1]<!-- -->.
Note: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval().</p><ul><li>Example 1: Input: s = &quot;3+2*2&quot;  Output: 7</li><li>Example 2: Input: s = &quot; 3/2 &quot; Output: 1</li><li>Example 3: Input: s = &quot; 3+5 / 2 &quot; Output: 5</li></ul><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int calculate(String s) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int len = s.length();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 字符串中包含空格，如何过滤掉？</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int num = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        char prevOp = &#x27;+&#x27;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int i = 0; i &lt; len; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            char c = s.charAt(i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 判断字符是否数字, 因为每次只能取一个字符，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(Character.isDigit(c)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 如果数字是两位，那就凉了，所以要累加</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 前一个乘以10 + 当前的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 这里记住，直接减去&#x27;0&#x27;得到数字</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                num = num * 10 + (c - &#x27;0&#x27;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 这里为什么要判断i?</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 因为循环到字符串末尾，已经不可能是字符了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 此刻就要判断了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 总之：开始计算的条件是要么遇到运算符，要么到达循环的末尾</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (!Character.isDigit(c) &amp;&amp; c != &#x27; &#x27; || i == len - 1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                switch(prevOp) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    case &#x27;+&#x27; :</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        stack.push(num);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    case &#x27;-&#x27; :</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        stack.push(-num);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    case &#x27;*&#x27; :</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        stack.push(stack.pop() * num);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    case &#x27;/&#x27; :</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        stack.push(stack.pop() / num);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                prevOp = c;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                num = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int result = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while(!stack.isEmpty()) result += stack.pop();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return result;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="155-min-stack">155. Min Stack<a href="#155-min-stack" class="hash-link" aria-label="Direct link to 155. Min Stack" title="Direct link to 155. Min Stack">​</a></h2><p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.
Implement the MinStack class:</p><ul><li>MinStack() initializes the stack object.</li><li>void push(int val) pushes the element val onto the stack.</li><li>void pop() removes the element on the top of the stack.</li><li>int top() gets the top element of the stack.</li><li>int getMin() retrieves the minimum element in the stack.
You must implement a solution with O(1) time complexity for each function.
Example 1:
Input
<!-- -->[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;]<!-- -->[],<!-- -->[-2]<!-- -->,<!-- -->[0]<!-- -->,<!-- -->[-3]<!-- -->,[],[],[],[]]
Output
<!-- -->[null,null,null,null,-3,null,0,-2]<!-- -->
Explanation
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin(); // return -3
minStack.pop();
minStack.top();    // return 0
minStack.getMin(); // return -2</li></ul><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class MinStack {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Stack&lt;Integer&gt; stack;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Stack&lt;Integer&gt; minStack;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public MinStack() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        stack = new Stack&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        minStack = new Stack&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void push(int x) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        stack.push(x);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(minStack.isEmpty()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            minStack.push(x);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return; // 这里忘了return 也是巨坑</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 这里有坑，小于等于都要放，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 如果出栈把最小值出掉，前面还有最小值，那就不对了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(x &lt;= minStack.peek()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            minStack.push(x);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void pop() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(stack.isEmpty()) return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int val = stack.pop();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 如果最小栈的栈顶元素等于出栈元素</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 最小栈出栈</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(minStack.peek() == val) minStack.pop();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int top() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return stack.peek();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int getMin() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(minStack.isEmpty()) return -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return minStack.peek();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="496-next-greater-element-i">496. Next Greater Element I<a href="#496-next-greater-element-i" class="hash-link" aria-label="Direct link to 496. Next Greater Element I" title="Direct link to 496. Next Greater Element I">​</a></h2><p>The next greater element of some element x in an array is the first greater element that is to the right of x in the same array.
You are given two distinct 0-indexed integer arrays nums1 and nums2, where nums1 is a subset of nums2.
For each 0 &lt;= i &lt; nums1.length, find the index j such that nums1<!-- -->[i]<!-- --> == nums2<!-- -->[j]<!-- --> and determine the next greater element of nums2<!-- -->[j]<!-- --> in nums2. If there is no next greater element, then the answer for this query is -1.
Return an array ans of length nums1.length such that ans<!-- -->[i]<!-- --> is the next greater element as described above.</p><ul><li>Example 1:<ul><li>Input: nums1 = <!-- -->[4,1,2]<!-- -->, nums2 = <!-- -->[1,3,4,2]</li><li>Output: <!-- -->[-1,3,-1]</li><li>Explanation: The next greater element for each value of nums1 is as follows:</li><li>4 is underlined in nums2 = <!-- -->[1,3,4,2]<!-- -->. There is no next greater element, so the answer is -1.</li><li>1 is underlined in nums2 = <!-- -->[1,3,4,2]<!-- -->. The next greater element is 3.</li><li>2 is underlined in nums2 = <!-- -->[1,3,4,2]<!-- -->. There is no next greater element, so the answer is -1.</li></ul></li><li>Example 2:<ul><li>Input: nums1 = <!-- -->[2,4]<!-- -->, nums2 = <!-- -->[1,2,3,4]</li><li>Output: <!-- -->[3,-1]</li><li>Explanation: The next greater element for each value of nums1 is as follows:</li><li>2 is underlined in nums2 = <!-- -->[1,2,3,4]<!-- -->. The next greater element is 3.</li><li>4 is underlined in nums2 = <!-- -->[1,2,3,4]<!-- -->. There is no next greater element, so the answer is -1.</li></ul></li></ul><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 把数组的元素想象成并列站立的人，元素大小想象成人的身高。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 这些人面对你站成一列，如何求元素「2」的 Next Greater Number呢？</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 很简单，如果能够看到元素「2」，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 那么他后面可见的第一个人就是「2」的Next Greater Number，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 因为比「2」小的元素身高不够，都被「2」挡住了，第一个露出来的就是答案。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                --------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                |      -------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            --------------------|      |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            |       -------|    |      |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            |       |      |    |      |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            2       1      2    4      3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            4       2      4    -1     -1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int[] nextGreaterElement(int[] nums1, int[] nums2) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 这里为什么要使用map，因为说了nums1是nums2的自己</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 那直接判断nums2里的元素就可以了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 由于Vector由于效率问题已经被弃用，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 因此继承Vector的Stack也存在效率问题，故不推荐使用。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Deque&lt;Integer&gt; deque = new ArrayDeque&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int i = nums2.length - 1; i &gt;= 0; i --) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int curVal = nums2[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 在当前这个curVal，比他小(矮)的元素全部出队</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            while(!deque.isEmpty() &amp;&amp; curVal &gt; deque.peek()) deque.pop();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 当前元素，下一个大的元素，要么栈空了是-1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 要么栈里面还有比他高的，就是下一个比他大的值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            map.put(curVal, deque.isEmpty() ? -1 : deque.peek());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 自己入队</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            deque.push(curVal);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 因为要返回数组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int[] arr = new int[nums1.length];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int i = 0; i &lt; nums1.length; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            arr[i] = map.get(nums1[i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return arr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="901-online-stock-span">901. Online Stock Span<a href="#901-online-stock-span" class="hash-link" aria-label="Direct link to 901. Online Stock Span" title="Direct link to 901. Online Stock Span">​</a></h2><p>Design an algorithm that collects daily price quotes for some stock and returns the span of that stock&#x27;s price for the current day.
The span of the stock&#x27;s price in one day is the maximum number of consecutive days (starting from that day and going backward) for which the stock price was less than or equal to the price of that day.</p><ul><li>For example, if the price of the stock in the last four days is <!-- -->[7,2,1,2]<!-- --> and the price of the stock today is 2, then the span of today is 4 because starting from today, the price of the stock was less than or equal 2 for 4 consecutive days.</li><li>Also, if the price of the stock in the last four days is <!-- -->[7,34,1,2]<!-- --> and the price of the stock today is 8, then the span of today is 3 because starting from today, the price of the stock was less than or equal 8 for 3 consecutive days.
Implement the StockSpanner class:</li><li>StockSpanner() Initializes the object of the class.</li><li>int next(int price) Returns the span of the stock&#x27;s price given that today&#x27;s price is price.
Example 1:
Input
<!-- -->[&quot;StockSpanner&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;]<!-- -->[], <!-- -->[100]<!-- -->, <!-- -->[80]<!-- -->, <!-- -->[60]<!-- -->, <!-- -->[70]<!-- -->, <!-- -->[60]<!-- -->, <!-- -->[75]<!-- -->, <!-- -->[85]<!-- -->]
Output <!-- -->[null, 1, 1, 1, 2, 1, 4, 6]</li></ul><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class StockSpanner {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 这里构建一个对象用来</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    class Pair {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int price; // 值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int count; // 数量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public Pair(int price, int count) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.price = price;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.count = count;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 这里大家都用deque，效率更高</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Deque&lt;Pair&gt; deque; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public StockSpanner() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        deque = new ArrayDeque&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 查找比当前小的之前的个数和？</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 维护单调递减栈</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 栈里保存的元素有：当前数量+ 小于等于当前数值的个数和</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int next(int price) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(deque.isEmpty()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 全部操作队尾，模拟栈</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            deque.offerLast(new Pair(price, 1));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int count = 1; // 自己本身也算一次</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 找出比当前值小的记录，全部出栈</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 核心是：之前有没有比我小的？有的话告诉我你的count是什么？</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 因为后面的元素比较到比自己大的元素就得停止</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while(!deque.isEmpty() &amp;&amp; deque.peekLast().price &lt;= price) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 累加比当前price小的数量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 全部操作队尾，模拟栈</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            count += deque.pollLast().count;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 再次放进栈中，供下一次判断使用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        deque.offerLast(new Pair(price, count));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return count;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/JonathanTube/Jonathan.Kong.github.com/tree/main/docs/leetcode/4.stack.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_vwxv"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/leetcode/queue"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Queue</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/leetcode/divide and conquer"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Divide and Conquer &amp; Recursion</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#232-implement-queue-using-stacks" class="table-of-contents__link toc-highlight">232. Implement Queue using Stacks</a></li><li><a href="#225-implement-stack-using-queues" class="table-of-contents__link toc-highlight">225. Implement Stack using Queues</a></li><li><a href="#20-valid-parentheses" class="table-of-contents__link toc-highlight">20. Valid Parentheses</a></li><li><a href="#856-score-of-parentheses" class="table-of-contents__link toc-highlight">856. Score of Parentheses</a></li><li><a href="#227-basic-calculator-ii" class="table-of-contents__link toc-highlight">227. Basic Calculator II</a></li><li><a href="#155-min-stack" class="table-of-contents__link toc-highlight">155. Min Stack</a></li><li><a href="#496-next-greater-element-i" class="table-of-contents__link toc-highlight">496. Next Greater Element I</a></li><li><a href="#901-online-stock-span" class="table-of-contents__link toc-highlight">901. Online Stock Span</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"></div></footer></div>
<script src="/assets/js/runtime~main.111a47fd.js"></script>
<script src="/assets/js/main.a6abb70e.js"></script>
</body>
</html>